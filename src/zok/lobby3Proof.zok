// This is intended to be the complete proof used for Lobby3 (after the leaf is added
// to the merkle tree). It is slightly more abstract than Lobby3's use case requires. 
// This more abstract version simply allows for more use cases to be built with it.
// The general proof scheme here does the following: Prove that the user knows the 
// preimage of a leaf was signed by Holonym. Proof that their credentials were signed
// by Holonym is accomplished via a merkle proof.


import "hashes/poseidon/poseidon" as poseidon;

const u32 DEPTH = 32;

// NOTE: Not needed for Lobby3
// Proves that user_nullifier+verifier_message is indeed the preimage of publicly provided nullifierHash
// This allows verifier to prevent sybil attacks
// @param nullifierHash - blake2s hash of nullifier+verifier_message
// def assertValidNullifier(u32[8] nullifierHash, u32[4] nullifier, u32[12] message) {
//     u32[1][16] preimage = [[...nullifier, ...message]];
//     assert(blake2s(preimage) == nullifierHash);
// }


def main(field address, field root, field countryCode, private field subdivision, private field completedAt, private field birthdate, private field leaf, private bool[DEPTH] directionSelector, private field[DEPTH] path, private field nullifier) {
    // assert valid preimage
    field[6] preimage = [address, nullifier, countryCode, subdivision, completedAt, birthdate];
    assert(poseidon(preimage) == leaf);
    
    // TODO: REWRITE THE MERKLE PROOF FOR QUINARY TREE
    // merkle proof
    field mut digest = leaf;
    for u32 i in 0..DEPTH {
        field[2] preimage2 = directionSelector[i] ? [path[i], digest] : [digest, path[i]];
        digest = poseidon(preimage2);
    }

    assert(digest == root);
    return;
}

// NOTE: For Lobby3, countryCode should be checked in smart contract